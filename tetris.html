<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тетрис | Drag & Drop Style</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            background-color: #111827;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            touch-action: manipulation;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .game-container {
            background: rgba(17, 24, 39, 0.8);
            border-radius: 16px;
            box-shadow: 0 0 30px rgba(99, 102, 241, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(99, 102, 241, 0.3);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 95%;
        }
        
        .game-board {
            border: 2px solid rgba(99, 102, 241, 0.5);
            border-radius: 8px;
            background-color: rgba(31, 41, 55, 0.7);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.2);
            position: relative;
            overflow: hidden;
            touch-action: none;
        }
        
        .block {
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-sizing: border-box;
            position: absolute;
            border-radius: 4px;
            transition: transform 0.1s, opacity 0.3s;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
            cursor: move;
            user-select: none;
            touch-action: none;
        }
        
        /* Яркие разноцветные блоки с градиентами и свечением */
        .block.I { 
            background: linear-gradient(135deg, #00f5d4, #00bbf9);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(0, 245, 212, 0.5);
        }
        .block.J { 
            background: linear-gradient(135deg, #8338ec, #3a86ff);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(131, 56, 236, 0.5);
        }
        .block.L { 
            background: linear-gradient(135deg, #ff9e00, #ff5400);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(255, 158, 0, 0.5);
        }
        .block.O { 
            background: linear-gradient(135deg, #38b000, #70e000);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(56, 176, 0, 0.5);
        }
        .block.S { 
            background: linear-gradient(135deg, #ff006e, #ff7096);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(255, 0, 110, 0.5);
        }
        .block.T { 
            background: linear-gradient(135deg, #9b5de5, #f15bb5);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(155, 93, 229, 0.5);
        }
        .block.Z { 
            background: linear-gradient(135deg, #ef233c, #d90429);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(239, 35, 60, 0.5);
        }
        
        /* Сетка игрового поля */
        .grid-cell {
            position: absolute;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-sizing: border-box;
        }
        
        .score-box {
            background-color: rgba(31, 41, 55, 0.7);
            border: 2px solid rgba(99, 102, 241, 0.5);
            border-radius: 8px;
            padding: 10px 20px;
            text-align: center;
            margin-bottom: 15px;
            width: 100%;
            max-width: 300px;
        }
        
        .preview-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 20px;
            gap: 10px;
        }
        
        .preview-piece {
            background-color: rgba(31, 41, 55, 0.7);
            border: 2px solid rgba(99, 102, 241, 0.5);
            border-radius: 8px;
            position: relative;
            flex: 1;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: transform 0.2s, box-shadow 0.2s;
            overflow: hidden;
            touch-action: none;
        }
        
        .preview-piece:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
        }
        
        .preview-piece:active {
            cursor: grabbing;
        }
        
        .preview-piece.empty {
            background-color: rgba(31, 41, 55, 0.3);
            border: 2px dashed rgba(99, 102, 241, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .preview-piece.empty::after {
            content: "+";
            color: rgba(255, 255, 255, 0.3);
            font-size: 24px;
            font-weight: bold;
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(17, 24, 39, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 16px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .game-over.show {
            opacity: 1;
            pointer-events: all;
        }
        
        .restart-btn {
            background: linear-gradient(135deg, #8338ec, #3a86ff);
            border: none;
            border-radius: 50px;
            padding: 12px 30px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(131, 56, 236, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(131, 56, 236, 0.6);
        }
        
        .restart-btn:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(131, 56, 236, 0.5);
        }
        
        .line-clear {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 3px;
            animation: lineClear 0.3s forwards;
            z-index: 5;
        }
        
        @keyframes lineClear {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
            100% { opacity: 0; transform: scale(0.5); }
        }
        
        .dragging {
            opacity: 0.8;
            transform: scale(1.05);
            z-index: 100;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.7) !important;
        }
        
        .instructions {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            margin-top: 15px;
            max-width: 300px;
        }
        
        .rotate-btn {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 5;
            transition: all 0.2s;
        }
        
        .rotate-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }
        
        /* Анимация появления блоков */
        @keyframes blockAppear {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .block {
            animation: blockAppear 0.3s ease-out;
        }
        
        /* Эффект при наведении на превью */
        .preview-piece:not(.empty):hover .block {
            filter: brightness(1.2);
            transform: scale(1.05);
        }
        
        /* Стиль для визуального элемента перетаскивания */
        #drag-visual {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
        
        /* Эффект при перетаскивании */
        .preview-piece.dragging-source {
            opacity: 0.4;
            transform: scale(0.95);
        }
        
        /* Подсветка при наведении */
        .hover-highlight {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            z-index: 5;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-3xl font-bold mb-4 text-white">
            <i class="fas fa-cubes text-blue-400 mr-2"></i>
            <span class="bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">Тетрис Drag & Drop</span>
        </h1>
        
        <div class="score-box">
            <div class="text-blue-300 text-sm">Очки</div>
            <div class="text-2xl font-bold text-white" id="score">0</div>
        </div>
        
        <div id="game-board" class="game-board" style="width: 300px; height: 300px;"></div>
        
        <p class="instructions">Перетащите фигуры из нижних ячеек на игровое поле</p>
        
        <div class="preview-container">
            <div class="preview-piece" id="preview-1"></div>
            <div class="preview-piece" id="preview-2"></div>
            <div class="preview-piece" id="preview-3"></div>
        </div>
        
        <div class="game-over" id="game-over">
            <h2 class="text-4xl font-bold text-blue-400 mb-4">Игра окончена!</h2>
            <p class="text-xl mb-6 text-white">Ваш счет: <span id="final-score">0</span></p>
            <button class="restart-btn" id="restart-btn">
                <i class="fas fa-play mr-2"></i> Играть снова
            </button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Константы игры
            const COLS = 10;
            const ROWS = 10;
            const BLOCK_SIZE = 30;
            
            // Элементы DOM
            const gameBoard = document.getElementById('game-board');
            const scoreElement = document.getElementById('score');
            const gameOverElement = document.getElementById('game-over');
            const finalScoreElement = document.getElementById('final-score');
            const restartBtn = document.getElementById('restart-btn');
            const preview1 = document.getElementById('preview-1');
            const preview2 = document.getElementById('preview-2');
            const preview3 = document.getElementById('preview-3');
            
            // Состояние игры
            let board = createBoard();
            let score = 0;
            let gameOver = false;
            let previewPieces = [];
            let activeDragPiece = null;
            let dragStartElement = null;
            let hoverHighlight = null;
            
            // Фигуры Тетриса
            const SHAPES = {
                I: {
                    shape: [
                        [0, 0, 0, 0],
                        [1, 1, 1, 1],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]
                    ],
                    color: 'I'
                },
                J: {
                    shape: [
                        [1, 0, 0],
                        [1, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'J'
                },
                L: {
                    shape: [
                        [0, 0, 1],
                        [1, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'L'
                },
                O: {
                    shape: [
                        [1, 1],
                        [1, 1]
                    ],
                    color: 'O'
                },
                S: {
                    shape: [
                        [0, 1, 1],
                        [1, 1, 0],
                        [0, 0, 0]
                    ],
                    color: 'S'
                },
                T: {
                    shape: [
                        [0, 1, 0],
                        [1, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'T'
                },
                Z: {
                    shape: [
                        [1, 1, 0],
                        [0, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'Z'
                }
            };
            
            // Случайная фигура
            function randomPiece() {
                const keys = Object.keys(SHAPES);
                const randomKey = keys[Math.floor(Math.random() * keys.length)];
                return Object.assign({}, SHAPES[randomKey]);
            }
            
            // Создание игрового поля
            function createBoard() {
                return Array.from({length: ROWS}, () => Array(COLS).fill(0));
            }
            
            // Рисование игрового поля
            function drawBoard() {
                // Очищаем игровое поле
                gameBoard.innerHTML = '';
                
                // Рисуем сетку
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.style.width = `${BLOCK_SIZE}px`;
                        cell.style.height = `${BLOCK_SIZE}px`;
                        cell.style.left = `${x * BLOCK_SIZE}px`;
                        cell.style.top = `${y * BLOCK_SIZE}px`;
                        gameBoard.appendChild(cell);
                    }
                }
                
                // Рисуем текущие блоки на поле
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x]) {
                            const block = document.createElement('div');
                            block.className = `block block-${board[y][x]}`;
                            block.style.width = `${BLOCK_SIZE}px`;
                            block.style.height = `${BLOCK_SIZE}px`;
                            block.style.left = `${x * BLOCK_SIZE}px`;
                            block.style.top = `${y * BLOCK_SIZE}px`;
                            gameBoard.appendChild(block);
                        }
                    }
                }
            }
            
            // Рисование превью фигур
            function drawPreviewPieces() {
                preview1.innerHTML = '';
                preview2.innerHTML = '';
                preview3.innerHTML = '';
                
                // Добавляем кнопки вращения
                previewPieces.forEach((piece, index) => {
                    const previewContainer = [preview1, preview2, preview3][index];
                    previewContainer.className = 'preview-piece';
                    
                    const previewWidth = previewContainer.offsetWidth;
                    const previewHeight = previewContainer.offsetHeight;
                    
                    // Центрируем фигуру в превью
                    const offsetX = (previewWidth - piece.shape[0].length * BLOCK_SIZE) / 2;
                    const offsetY = (previewHeight - piece.shape.length * BLOCK_SIZE) / 2;
                    
                    for (let y = 0; y < piece.shape.length; y++) {
                        for (let x = 0; x < piece.shape[y].length; x++) {
                            if (piece.shape[y][x]) {
                                const block = document.createElement('div');
                                block.className = `block block-${piece.color}`;
                                block.style.width = `${BLOCK_SIZE}px`;
                                block.style.height = `${BLOCK_SIZE}px`;
                                block.style.left = `${offsetX + x * BLOCK_SIZE}px`;
                                block.style.top = `${offsetY + y * BLOCK_SIZE}px`;
                                block.dataset.pieceIndex = index;
                                block.dataset.blockX = x;
                                block.dataset.blockY = y;
                                previewContainer.appendChild(block);
                            }
                        }
                    }
                    
                    // Добавляем кнопку вращения
                    const rotateBtn = document.createElement('button');
                    rotateBtn.className = 'rotate-btn';
                    rotateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                    rotateBtn.dataset.pieceIndex = index;
                    rotateBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        rotatePreviewPiece(parseInt(this.dataset.pieceIndex));
                    });
                    previewContainer.appendChild(rotateBtn);
                });
                
                // Заполняем пустые превью
                for (let i = previewPieces.length; i < 3; i++) {
                    const previewContainer = [preview1, preview2, preview3][i];
                    previewContainer.className = 'preview-piece empty';
                }
                
                // Обновляем обработчики событий для перетаскивания
                setupDragAndDrop();
            }
            
            // Проверка столкновений
            function collision(x, y, shape) {
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (!shape[row][col]) continue;
                        
                        const newX = x + col;
                        const newY = y + row;
                        
                        if (
                            newX < 0 || 
                            newX >= COLS || 
                            newY >= ROWS ||
                            (newY >= 0 && board[newY][newX])
                        ) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // Проверка заполненных линий
            function checkLines() {
                const linesToClear = [];
                
                // Находим заполненные линии
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (board[y].every(cell => cell !== 0)) {
                        linesToClear.push(y);
                    }
                }
                
                if (linesToClear.length > 0) {
                    // Анимация удаления линий
                    animateLineClear(linesToClear);
                    
                    // Удаляем линии и добавляем очки
                    clearLines(linesToClear);
                }
            }
            
            // Анимация удаления линий
            function animateLineClear(lines) {
                lines.forEach(y => {
                    for (let x = 0; x < COLS; x++) {
                        const lineClear = document.createElement('div');
                        lineClear.className = 'line-cclear';
                        lineClear.style.width = `${BLOCK_SIZE}px`;
                        lineClear.style.height = `${BLOCK_SIZE}px`;
                        lineClear.style.left = `${x * BLOCK_SIZE}px`;
                        lineClear.style.top = `${y * BLOCK_SIZE}px`;
                        gameBoard.appendChild(lineClear);
                    }
                });
            }
            
            // Удаление линий и добавление очков
            function clearLines(lines) {
                // Сортируем линии сверху вниз
                lines.sort((a, b) => a - b);
                
                // Добавляем очки в зависимости от количества собранных линий
                const linePoints = [0, 40, 100, 300, 1200]; // Очки за 0, 1, 2, 3, 4 линии
                const points = linePoints[lines.length];
                score += points;
                scoreElement.textContent = score;
                
                // Удаляем линии и сдвигаем остальные вниз
                for (const line of lines) {
                    board.splice(line, 1);
                    board.unshift(Array(COLS).fill(0));
                }
                
                drawBoard();
            }
            
            // Создание новых фигур для превью
            function createPreviewPieces() {
                previewPieces = [
                    randomPiece(),
                    randomPiece(),
                    randomPiece()
                ];
                drawPreviewPieces();
            }
            
            // Поворот фигуры в превью
            function rotatePreviewPiece(index) {
                if (index >= previewPieces.length) return;
                
                const originalShape = previewPieces[index].shape;
                const rows = originalShape.length;
                const cols = originalShape[0].length;
                
                // Создаем новую повернутую матрицу
                const rotated = Array.from({length: cols}, () => Array(rows).fill(0));
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        rotated[x][rows - 1 - y] = originalShape[y][x];
                    }
                }
                
                previewPieces[index].shape = rotated;
                drawPreviewPieces();
            }
            
            // Показ экрана окончания игры
            function showGameOver() {
                finalScoreElement.textContent = score;
                gameOverElement.classList.add('show');
            }
            
            // Скрытие экрана окончания игры
            function hideGameOver() {
                gameOverElement.classList.remove('show');
            }
            
            // Начало новой игры
            function startGame() {
                // Сброс состояния игры
                board = createBoard();
                score = 0;
                gameOver = false;
                
                scoreElement.textContent = score;
                
                hideGameOver();
                
                // Создаем превью фигур
                createPreviewPieces();
                
                drawBoard();
            }
            
            // Проверка конца игры
            function checkGameOver() {
                // Проверяем, есть ли блоки в верхней строке
                for (let x = 0; x < COLS; x++) {
                    if (board[0][x] !== 0) {
                        gameOver = true;
                        showGameOver();
                        return true;
                    }
                }
                return false;
            }
            
            // Обработчики событий для перетаскивания фигур
            function setupDragAndDrop() {
                const previewBlocks = document.querySelectorAll('.preview-piece .block');
                
                previewBlocks.forEach(block => {
                    // Удаляем старые обработчики, если они есть
                    block.removeEventListener('mousedown', startDrag);
                    block.removeEventListener('touchstart', startDrag);
                    
                    // Добавляем новые обработчики
                    block.addEventListener('mousedown', startDrag);
                    block.addEventListener('touchstart', startDrag, { passive: false });
                });
                
                // Удаляем старые обработчики, если они есть
                document.removeEventListener('mousemove', dragPiece);
                document.removeEventListener('touchmove', dragPiece);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchend', endDrag);
                
                // Добавляем новые обработчики
                document.addEventListener('mousemove', dragPiece);
                document.addEventListener('touchmove', dragPiece, { passive: false });
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchend', endDrag);
            }
            
            function startDrag(e) {
                if (gameOver) return;
                
                e.preventDefault();
                
                const pieceIndex = parseInt(e.target.dataset.pieceIndex);
                const blockX = parseInt(e.target.dataset.blockX);
                const blockY = parseInt(e.target.dataset.blockY);
                
                if (pieceIndex >= previewPieces.length) return;
                
                // Запоминаем элемент, с которого начали перетаскивание
                dragStartElement = e.target.closest('.preview-piece');
                dragStartElement.classList.add('dragging-source');
                
                // Создаем копию фигуры для перетаскивания
                activeDragPiece = {
                    ...previewPieces[pieceIndex],
                    pieceIndex: pieceIndex,
                    dragX: e.clientX || e.touches[0].clientX,
                    dragY: e.clientY || e.touches[0].clientY,
                    offsetX: blockX * BLOCK_SIZE,
                    offsetY: blockY * BLOCK_SIZE
                };
                
                // Добавляем класс для визуального эффекта
                e.target.classList.add('dragging');
                
                // Создаем визуальное представление перетаскиваемой фигуры
                const dragVisual = document.createElement('div');
                dragVisual.id = 'drag-visual';
                document.body.appendChild(dragVisual);
                
                // Рисуем всю фигуру для перетаскивания
                for (let y = 0; y < activeDragPiece.shape.length; y++) {
                    for (let x = 0; x < activeDragPiece.shape[y].length; x++) {
                        if (activeDragPiece.shape[y][x]) {
                            const block = document.createElement('div');
                            block.className = `block block-${activeDragPiece.color}`;
                            block.style.width = `${BLOCK_SIZE}px`;
                            block.style.height = `${BLOCK_SIZE}px`;
                            block.style.left = `${x * BLOCK_SIZE}px`;
                            block.style.top = `${y * BLOCK_SIZE}px`;
                            dragVisual.appendChild(block);
                        }
                    }
                }
                
                // Создаем подсветку для предпросмотра позиции
                hoverHighlight = document.createElement('div');
                hoverHighlight.className = 'hover-highlight';
                hoverHighlight.style.width = `${activeDragPiece.shape[0].length * BLOCK_SIZE}px`;
                hoverHighlight.style.height = `${activeDragPiece.shape.length * BLOCK_SIZE}px`;
                gameBoard.appendChild(hoverHighlight);
                
                // Обновляем позицию сразу
                updateDragPosition(e);
            }
            
            function dragPiece(e) {
                if (!activeDragPiece) return;
                
                e.preventDefault();
                updateDragPosition(e);
            }
            
            function updateDragPosition(e) {
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                // Обновляем позицию визуального элемента
                const dragVisual = document.getElementById('drag-visual');
                if (dragVisual) {
                    dragVisual.style.left = `${clientX}px`;
                    dragVisual.style.top = `${clientY}px`;
                }
                
                // Обновляем подсветку позиции на игровом поле
                if (hoverHighlight) {
                    const rect = gameBoard.getBoundingClientRect();
                    const boardX = Math.floor((clientX - rect.left) / BLOCK_SIZE);
                    const boardY = Math.floor((clientY - rect.top) / BLOCK_SIZE);
                    
                    // Позиционируем подсветку точно по сетке
                    if (boardX >= 0 && boardX < COLS && boardY >= 0 && boardY < ROWS) {
                        hoverHighlight.style.left = `${boardX * BLOCK_SIZE}px`;
                        hoverHighlight.style.top = `${boardY * BLOCK_SIZE}px`;
                        hoverHighlight.style.display = 'block';
                    } else {
                        hoverHighlight.style.display = 'none';
                    }
                }
            }
            
            function endDrag(e) {
                if (!activeDragPiece) return;
                
                e.preventDefault();
                
                // Удаляем визуальный элемент
                const dragVisual = document.getElementById('drag-visual');
                if (dragVisual) {
                    dragVisual.remove();
                }
                
                // Удаляем подсветку
                if (hoverHighlight) {
                    hoverHighlight.remove();
                    hoverHighlight = null;
                }
                
                // Удаляем класс dragging
                const draggingBlocks = document.querySelectorAll('.block.dragging');
                draggingBlocks.forEach(block => block.classList.remove('dragging'));
                
                // Удаляем класс dragging-source
                if (dragStartElement) {
                    dragStartElement.classList.remove('dragging-source');
                    dragStartElement = null;
                }
                
                // Получаем координаты на игровом поле
                const rect = gameBoard.getBoundingClientRect();
                const clientX = e.clientX || (e.changedTouches ? e.changedTouches[0].clientX : 0);
                const clientY = e.clientY || (e.changedTouches ? e.changedTouches[0].clientY : 0);
                
                // Проверяем, что отпустили на игровом поле
                if (clientX >= rect.left && clientX <= rect.right && 
                    clientY >= rect.top && clientY <= rect.bottom) {
                    
                    // Вычисляем координаты на поле
                    const boardX = Math.floor((clientX - rect.left) / BLOCK_SIZE);
                    const boardY = Math.floor((clientY - rect.top) / BLOCK_SIZE);
                    
                    // Проверяем, можно ли разместить фигуру
                    if (!collision(boardX, boardY, activeDragPiece.shape)) {
                        // Размещаем фигуру на поле точно в выбранной позиции
                        for (let y = 0; y < activeDragPiece.shape.length; y++) {
                            for (let x = 0; x < activeDragPiece.shape[y].length; x++) {
                                if (activeDragPiece.shape[y][x]) {
                                    const newY = boardY + y;
                                    const newX = boardX + x;
                                    
                                    if (newY >= 0 && newY < ROWS && newX >= 0 && newX < COLS) {
                                        board[newY][newX] = activeDragPiece.color;
                                    }
                                }
                            }
                        }
                        
                        // Удаляем использованную фигуру из превью
                        previewPieces.splice(activeDragPiece.pieceIndex, 1);
                        
                        // Проверяем линии
                        checkLines();
                        
                        // Проверяем конец игры
                        if (!checkGameOver()) {
                            // Если превью пустые, создаем новые фигуры
                            if (previewPieces.length === 0) {
                                createPreviewPieces();
                            } else {
                                drawPreviewPieces();
                            }
                            
                            drawBoard();
                        }
                    }
                }
                
                activeDragPiece = null;
            }
            
            restartBtn.addEventListener('click', startGame);
            
            // Начинаем игру
            startGame();
        });
    </script>
</body>
</html>